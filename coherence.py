# -*- coding: utf-8 -*-
"""
Created on Fri Jan 10 12:45:46 2020

Tools for wrangling and visualizing coherence data for our tetrode recordings

@author: earnestt
"""
import datetime
import itertools
import matplotlib.animation as animation
import natsort
import numpy as np
import os
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import sys

from mne.viz import plot_connectivity_circle
from sklearn.decomposition import PCA

class Load():
    """"Class for accessing all coherence-data loading classes.
    Use the syntax: Load().COHERENCE_FUNCTION(ARGUMENTS).
    All attributes of Load() are "COHERENCE_FUNCTIONS" which work
    on directories.

    COHERENCE_FUNCTIONS:
    Coherence_Matrix: load coherence data from one time bin.
        Used for making matrix & circle plots
    Coherence_1D: load coherence data from one time bin as a 1D array
        Used for doing PCA
    Coherence_Matrix_Overtime: load coherence data from multiple time bins
        Used for making matrix & circle plots
    Coherence_1D_Overtime: load coherence data from multiple time bins
        as 1D DataFrames, used for doing PCA
    """
    def __init__(self):
        """Point to the desired loading function"""
        self.Coherence_Matrix = Coherence_Matrix
        self.Coherence_1D = Coherence_1D
        self.Coherence_Matrix_Overtime = Coherence_Matrix_Overtime
        self.Coherence_1D_Overtime = Coherence_1D_Overtime

class Coherence_Matrix():
    """
        Compute and load the coherence matrix of given frequencies for a directory
    containing coherence data.
        The directory should be a folder containing .csv files with "coherence
    matrices", i.e. a matrix of the coherence of LFPs between tetrode wires at
    different frequencies from 0-100 Hz. There should be one .csv file for each
    reference wire.
        The desired directory can be generated by our NEx scripts, such as
    coherence_4_tetrodes or coherence_4_tetrodes_withfilter, available in
    Tetrode Analysis/analysis scripts. These make use of custom Coherence
    NEx templates, available in Tetrode Analysis/nex templates.

    ---Constructor Arguments---
    directory : str
      the file path of the directory to analyze
    freq_min : int, default 0
      the lower limit of frequencies for computing average coherence
    freq_max : int, default 100
      the upper limit of frequencies for computing average coherence
    band : str, default None
      brain wave oscillation band used to overwrite frequency arguments
    rows : list or range, default None
      denotes the wire numbers of rows to include, using 1-based rather than
      Python's 0-based indexing.
    cols : list or range, default None
      denotes the wire numbers of columns to include, using 1-based rather than
      Python's 0-based indexing.
    **kwargs : range, list, or instance of Region()
        kwargs with the structure 'reg_{region name}' can be passed to give names
        to wires, using 1-based indexing to identify wires.  Or, instances of
        Region() can be passed. Each regions wires will be named with the
        format '{region name} {#}'. Region kwargs can overwrite each other,
        with hierarchy based on the order they are passed.
        Regions() should be passed with an arbitrary keyword argument.

    ---Methods---
    plot() - plot the loaded data as a matrix or circle

    ---Attributes---
    data : DataFrame of the coherence matrix
    directory : directory
    freq_min : freq_min
    freq_max : freq_max
    band : band
    rows : rows (converted to 0-based index)
    cols : cols (converted to 0-based index)
    kwargs : dict of all kwargs passed
    ---------------
    Written by Tom Earnest
    January 2020
    earnestt1234@gmail.com
    """
    def __init__(self,
                 directory,
                 freq_min = 0,
                 freq_max = 100,
                 band = None,
                 rows = None,
                 cols = None,
                 **kwargs):
        """Constructs the matrix and saves associated information in
        attributes"""

        self.directory = directory
        self.freq_min = freq_min
        self.freq_max = freq_max
        self.band = band
        self.rows = rows
        self.cols = cols
        self.kwargs = {key: val for key, val in kwargs.items()}

        ##################
        #CHECKS / WARNINGS
        ##################

        #makes sure path exists
        assert os.path.isdir(directory), ("Stopping: cannot find '" +
                                          directory +  "'."
                                          "Please check the folder argument.")

        #checks if all files in the directory are .csv files,
        #reports a warning if not
        c = 0
        while c < len(os.listdir(directory)):
          if sorted(os.listdir(directory))[c][-4:] != '.csv':
            print("Warning: at least one file is not a .csv."
                  " Running only the .csv files")
            break
          else:
            c+=1

        #checking frequency arguments:
        assert freq_max > freq_min, ('Stopping:'
                                     ' "freq_min" must be less than "freq_max"')

        if (freq_min < 0 or freq_min > 100) or (freq_max < 0 or freq_max >100):
          print('Stopping: frequency arguments must be between 0 and 100.')
          sys.exit()

        if self.band:
            self.freq_min = get_frequencies(band)[0]
            self.freq_max = get_frequencies(band)[1]

        if self.rows == None:
            num = len(os.listdir(directory))
            self.rows = range(1,num)
        if self.cols == None:
            self.cols = self.rows

        #checks the axis arguments
        if type(self.rows) == list:
          if all(isinstance(x, int) for x in self.rows):
            self.rows = [x-1 for x in self.rows]
        elif type(self.rows) == range:
          self.rows = [x-1 for x in self.rows]
          self.rows.append(self.rows[-1]+1)

        if type(self.cols) == list:
          if all(isinstance(x, int) for x in self.cols):
            self.cols = [x-1 for x in self.cols]
        elif type(self.cols) == range:
          self.cols = [x-1 for x in self.cols]
          self.cols.append(self.cols[-1]+1)

        assert(type(self.rows == list)), '\nStopping, "rows" argument is not a list of integers or range'
        assert(type(self.cols == list)), '\nStopping, "cols" argument is not a list of integers or range'

        ####################
        #COMPUTING COHERENCE
        ####################

        #creates an empty list
        band_list = []

        #loops over all files in the directory
        #sorted() is used to make sure this is done in order
        for i in sorted(os.listdir(directory)):
          path = os.path.join(directory, i)
          if path[-4:] == '.csv':

            #loads .csvs into a DataFrame
            df = pd.read_csv(path)

            #finds the coherence values between the two frequency limits for the given band
            #computes the average coherence values for the band; these are saved as an array
            #adds the array to our empty list (band_list is a list of arrays)
            try:
              banddf = df[(df["Frequency Value"]>=self.freq_min) & (df["Frequency Value"]<self.freq_max)]
            except KeyError:
              try:
                banddf = df[(df["Frequency"]>=self.freq_min) & (df["Frequency"]<self.freq_max)]
              except KeyError:
                print("The name of the frequency column is not known by the function.")
                print("We will need to edit the code to include this case.")
                print("Stopping the function")
                return

            band_coherences = banddf.loc[:,"FP01":].mean()
            band_list.append(band_coherences)

        #converts the list into a DataFrame
        band_matrix = pd.DataFrame(band_list)

        #all wires are given generic FP names
        #these are taken from the columns, and the indices (row names)
        #are renamed
        band_matrix = band_matrix.rename(index = dict(zip(list(band_matrix.index.values),list(band_matrix.columns))))

        #but if region kwargs are passed, they are used to overwrite wire names:

        #loop over all the kwargs passed
        for i in kwargs:

          #process if they are formatted as a region
          if i[:4] == 'reg_':

            #handles lists, converting to 1-based index
            #only tried if all values are integers
            if type(kwargs[i]) == list:
              if all(isinstance(x, int) for x in kwargs[i]):
                kwargs[i] = [x-1 for x in kwargs[i]]

            #handles ranges, coverting to 1-based index
            elif type(kwargs[i]) == range:
              kwargs[i] = [x-1 for x in kwargs[i]]
              kwargs[i].append(kwargs[i][-1]+1)

            #pulls the region name from the kwarg
            #make as dictionary relating wire numbers to region numbers
            #for each value specified by the region, a dict entry is made
            #where the wire number is the key and the region name is the value
            regname = i[4:]
            regdict = {}
            for j in range(len(kwargs[i])):
              regdict[kwargs[i][j]] = regname + " " + str(j+1)


            #updating axis names

            #old names are copied, new names are copied to edit
            old_names = list(band_matrix.index)
            new_names = list(band_matrix.index)

            #for the index of each row/column name,
            #if the value matches an item in the kwarg's list
            #replace the name at that index
            for k in range(len(new_names)):
              if k in kwargs[i]:
                new_names[k] = regdict[k]

            #after all kwargs have been processed
            #rename both the rows and columns names with the updated names
            band_matrix = band_matrix.rename(index = dict(zip(old_names, new_names)))
            band_matrix = band_matrix.rename(columns = dict(zip(old_names, new_names)))

          #process if the kwarg is a Region instance
          elif isinstance(kwargs[i], Region):
            obj = kwargs[i]
            regname = obj.name
            regdict = {}
            for j in range(len(obj.axis1)):
              regdict[obj.axis1[j]] = regname + " " + str(j+1)

            #updating axis names

            #old names are copied, new names are copied to edit
            old_names = list(band_matrix.index)
            new_names = list(band_matrix.index)

            #for the index of each row/column name,
            #if the value matches an item in the kwarg's list
            #replace the name at that index
            for k in range(len(new_names)):
              if k in obj.axis1:
                new_names[k] = regdict[k]

            #after all kwargs have been processed
            #rename both the rows and columns names with the updated names
            band_matrix = band_matrix.rename(index = dict(zip(old_names, new_names)))
            band_matrix = band_matrix.rename(columns = dict(zip(old_names, new_names)))

          else:
            print('WARNING: keyword argument "' + i +'" not recognized')

        #now slice the data based on rows/cols arguments
        #which will be taken from the user's axis1/axis2 arguments
        band_matrix = band_matrix.iloc[self.rows,self.cols]

        self.data = band_matrix

    def __str__(self):
        return ("Coherence Matrix(" + self.directory + ")" +
                '\nrows: ' + str(len(self.rows)) +
                '\ncolumns: ' + str(len(self.cols)) +
                '\nband: ' + str(self.band) +
                '\nfrequency: ' + str(self.freq_min) + '-'
                + str(self.freq_max) + ' Hz')

    def __repr__(self):
        return str({'directory': self.directory,
                'rows': self.rows,
                'columns': self.cols,
                'band': self.band,
                'freq_min': self.freq_min,
                'freq_max': self.freq_max})

    def plot(self, graph_type):
        """plot the loaded data as a circle or matrix plots

        ---Arguments---
        graph_type : str
            'circle' or 'matrix'
        """
        assert isinstance(self.data, pd.DataFrame), ('Cannot find Dataframe'
                                                     'in "self.data".')
        assert graph_type in ['circle','matrix'], ('"graph_type" must be'
                                                    '"circle" or "matrix".')
        band_matrix = self.data

        if graph_type == 'matrix':
            fig, ax1 = plt.subplots(figsize=(7,7))
            plt.tight_layout()


            plot1 = ax1.matshow(self.data, cmap='plasma', vmin=0, vmax=1)
            ax1.set_xticks(np.arange(len(band_matrix.columns)))
            ax1.set_yticks(np.arange(len(band_matrix.index)))
            ax1.set_ylim(len(band_matrix.index)-0.5, -0.5) #see this bug: https://github.com/matplotlib/matplotlib/issues/14751
            ax1.set_xticklabels(band_matrix.columns, ha='left')
            ax1.set_yticklabels(band_matrix.index.values)
            ax1.tick_params('x', labelrotation = 45)
            ax1.figure.colorbar(plot1, ax = ax1, shrink=.5)

        elif graph_type == 'circle':

            if self.rows == self.cols:
              cir_data = band_matrix
              indices = None
              nodes = band_matrix.columns

            #if not equivalent, extra processing must be done
            elif self.rows != self.cols:
              convert_dict = circleplot_matrix_to_1d(band_matrix)
              cir_data = convert_dict['cir_data']
              indices = convert_dict['indices']
              nodes = convert_dict['nodes']

            #establishes the figure, using the function from MNE
            fig, ax = plt.subplots(figsize=(10,10), facecolor='black')
            plt.tight_layout()
            plot_connectivity_circle(np.array(cir_data),
                                              node_names=nodes,
                                              facecolor='black',
                                              fig = fig,
                                              fontsize_names=10,
                                              colorbar_size=.2,
                                              fontsize_colorbar=10,
                                              linewidth=1,
                                              fontsize_title = 20,
                                              colormap = 'hot',
                                              vmin=0,
                                              vmax=1,
                                              indices = indices)
        return fig

class Coherence_Matrix_Average():
    """like Coherence_Matrix, but takes a list of directories
    and averages their data

    ---Constructor Arguments---
    directory_list : iterable
      list of file paths to average coherence data from
    freq_min : int, default 0
      the lower limit of frequencies for computing average coherence
    freq_max : int, default 100
      the upper limit of frequencies for computing average coherence
    band : str, default None
      brain wave oscillation band used to overwrite frequency arguments
    rows : list or range, default None
      denotes the wire numbers of rows to include, using 1-based rather than
      Python's 0-based indexing.
    cols : list or range, default None
      denotes the wire numbers of columns to include, using 1-based rather than
      Python's 0-based indexing.
    **kwargs : range, list, or instance of Region()
        kwargs with the structure 'reg_{region name}' can be passed to give names
        to wires, using 1-based indexing to identify wires.  Or, instances of
        Region() can be passed. Each regions wires will be named with the
        format '{region name} {#}'. Region kwargs can overwrite each other,
        with hierarchy based on the order they are passed.
        Regions() should be passed with an arbitrary keyword argument.

    ---Attributes---
    data : DataFrame of the coherence matrix
    directory : directory
    freq_min : freq_min
    freq_max : freq_max
    band : band
    rows : rows (converted to 0-based index)
    cols : cols (converted to 0-based index)
    kwargs : dict of all kwargs passed
    ---------------
    Written by Tom Earnest
    February 2020
    earnestt1234@gmail.com
    """
    def __init__(self,
                 directory_list,
                 freq_min = 0,
                 freq_max = 100,
                 band = None,
                 rows = None,
                 cols = None,
                 **kwargs):
        """Averages coherence data from multiple directories"""

        self.directory_list = directory_list

        #loading the average data first, establishing attributes after
        coherence_list = []
        for path in directory_list:
            assert os.path.isdir(path), ("Stopping: cannot find '" +
                                              path +  "'."
                                              "Please check the directory_list argument.")
            path_coherence = Coherence_Matrix(directory=path,
                                              freq_min=freq_min,
                                              freq_max=freq_max,
                                              band=band,
                                              rows=rows,
                                              cols=cols,
                                              **kwargs)
            coherence_list.append(path_coherence.data)

        #compute average coherence
        self.data = sum(coherence_list)/len(coherence_list)

        #grab attributes from last used directory
        #pulls the processing done in Coherence_Matrix
        self.freq_min = path_coherence.freq_min
        self.freq_max = path_coherence.freq_max
        self.band = path_coherence.band
        self.rows = path_coherence.rows
        self.cols = path_coherence.rows
        self.kwargs = path_coherence.kwargs

class Coherence_1D():
    """
    Compute and load the coherence matrix as a 1D array for a given band
    or given frequencies.

    The directory should be a folder containing .csv files with "coherence
    matrices", i.e. a matrix of the coherence of LFPs between tetrode wires at
    different frequencies from 0-100 Hz. There should be one .csv file for each
    reference wire.

    The desired directory can be generated by our NEx scripts, such as
    coherence_4_tetrodes or coherence_4_tetrodes_withfilter, available in
    /Tetrode Analysis/analysis scripts. These make use of custom Coherence
    NEx templates, available in /Tetrode Analysis/nex templates.

    ---Constructor Arguments---
    directory : str
      the file path of the directory to analyze
    freq_min : int, default 0
      the lower limit of frequencies for computing average coherence
    freq_max : int, default 100
      the upper limit of frequencies for computing average coherence
    band : str, default None
      brain wave oscillation band used to overwrite frequency arguments
    wirenames : list of Regions()
      instances of the Region class used to name wires; Regions should have
      equal axes and refer to one brain region
    **kwargs : instances of Region()
        Region() objects are used to slice the raw data.  They are used to
        choose which cells of a coherence matrix are added to the 1-dimensional
        DataFrame.  For each Region() "x" passed, the resulting 1-D
        DataFrame will include all wires marked by x.axis1 & x.axis2.
        Regions() should be passed with an arbitrary keyword argument.

    ---Attributes---
    data : DataFrame of the coherence matrix (1D)
    directory : directory
    freq_min : freq_min
    freq_max : freq_max
    band : band
    wirenames : wirenames
    kwargs : dict of all kwargs passed
    ---------------
    Written by Tom Earnest
    January 2020
    earnestt1234@gmail.com
    """
    def __init__(self,
                 directory,
                 freq_min = 0,
                 freq_max = 100,
                 band = None,
                 wirenames = None,
                 **kwargs):

        self.directory = directory
        self.freq_min = freq_min
        self.freq_max = freq_max
        self.band = band
        self.wirenames = wirenames
        self.kwargs = {key: val for key, val in kwargs.items()}

        ##################
        #CHECKS / WARNINGS
        ##################

        #makes sure path exists
        if not os.path.isdir(directory):
          print("Stopping: cannot find '" + directory +  "'.  Please check the folder argument.")
          sys.exit()

        #checks if all files in the directory are .csv files,
        #reports a warning if not
        c = 0
        while c < len(os.listdir(directory)):
          if sorted(os.listdir(directory))[c][-4:] != '.csv':
            print("Warning: at least one file is not a .csv.  Running the program only for the .csv files")
            break
          else:
            c+=1

        #checking frequency arguments:
        if not freq_max > freq_min:
          print('Stopping: "freq_min" must be less than "freq_max"')
          sys.exit()

        if (freq_min < 0 or freq_min > 100) or (freq_max < 0 or freq_max >100):
          print('Stopping: frequency arguments must be between 0 and 100.')
          sys.exit()

        if self.band:
            self.freq_min = get_frequencies(band)[0]
            self.freq_max = get_frequencies(band)[1]

        #check the wirenames:
        if wirenames != None:
          assert(isinstance(wirenames, list)), ('\nStopping, "wirenames" must be a list')
          for i in wirenames:
            assert(isinstance(i, Region)), ('\nStopping, ' + i + ' in "wirenames" '+
                                            'is not a Region.')


        ####################
        #COMPUTING COHERENCE
        ####################

        #creates an empty list
        band_list = []

        #loops over all files in the directory
        #sorted() is used to make sure this is done in order
        for i in sorted(os.listdir(directory)):
          path = os.path.join(directory,i)
          if path[-4:] == '.csv':

            #loads .csvs into a DataFrame
            df = pd.read_csv(path)

            #finds the coherence values between the two frequency limits for the given band
            #computes the average coherence values for the band; these are saved as an array
            #adds the array to our empty list (band_list is a list of arrays)
            try:
              banddf = df[(df["Frequency Value"]>=self.freq_min) & (df["Frequency Value"]<self.freq_max)]
            except KeyError:
              try:
                banddf = df[(df["Frequency"]>=self.freq_min) & (df["Frequency"]<self.freq_max)]
              except KeyError:
                print("The name of the frequency column is not known by the function.")
                print("We will need to edit the code to include this case.")
                print("Stopping the function")
                return

            band_coherences = banddf.loc[:,"FP01":].mean()
            band_list.append(band_coherences)

        #converts the list into a DataFrame
        band_matrix = pd.DataFrame(band_list)

        #all wires are given generic FP names
        #these are taken from the columns, and the indices (row names)
        #are renamed
        band_matrix = band_matrix.rename(index = dict(zip(list(band_matrix.index.values),
                                                          list(band_matrix.columns))))

        #renaming the wires from wirenames
        if wirenames != None:
          for obj in wirenames:
            regname = obj.name
            regdict = {}
            for j in range(len(obj.axis1)):
              regdict[obj.axis1[j]] = regname + " " + str(j+1)

            #updating axis names

            #old names are copied, new names are copied to edit
            old_names = list(band_matrix.index)
            new_names = list(band_matrix.index)

            #for the index of each row/column name,
            #if the value matches an item in the kwarg's list
            #replace the name at that index
            for k in range(len(new_names)):
              if k in obj.axis1:
                new_names[k] = regdict[k]

            #after all kwargs have been processed
            #rename both the rows and columns names with the updated names
            band_matrix = band_matrix.rename(index = dict(zip(old_names, new_names)))
            band_matrix = band_matrix.rename(columns = dict(zip(old_names, new_names)))

        #slicing the data if **kwargs are passed:
        data_dict = {}
        name_dict = {}
        region_kwargs = False

        for kwarg in kwargs:
          if isinstance(kwargs[kwarg], Region):
            region_kwargs = True
            obj2 = kwargs[kwarg]
            data_slice = band_matrix.iloc[obj2.axis1, obj2.axis2]
            data_dict[obj2.name] = data_slice.stack().to_list()
            name_x = []
            for col in obj2.axis1:
              for row in obj2.axis2:
                name_x.append(str(band_matrix.columns[col] + ' x ' + band_matrix.index[row]))
            name_dict[obj2.name] = name_x

        coherence_data_1d = []
        coherence_data_1d_names = []
        for i in data_dict:
          coherence_data_1d += data_dict[i]
          coherence_data_1d_names += name_dict[i]

        coherence_data_1d = pd.DataFrame([coherence_data_1d])
        coherence_data_1d.columns = coherence_data_1d_names
        coherence_data_1d.index.name = 'Frame'

        if not region_kwargs:
          name_x = []
          for col in band_matrix.columns:
            for row in band_matrix.index:
              name_x.append(col + ' x ' + row)

          coherence_data_1d = band_matrix.stack().to_list()
          coherence_data_1d = pd.DataFrame([coherence_data_1d])
          coherence_data_1d.columns = name_x
          coherence_data_1d.index.name = 'Frame'

        self.data = coherence_data_1d


class Coherence_Matrix_Overtime():
    """
    Compute and load coherence matrices for multiple time bins.
        The directory should be a superfolder containing subfolders which
    each contain .csv files with "coherence matrices", i.e. a matrix of the
    coherence of LFPs between tetrode wires at different frequencies from
    0-100 Hz. There should be one .csv file for each reference wire, and
    one subfolder for each time bin.
        The desired directory can be generated by our NEx scripts, such as
    coherence_4_tetrodes_overtime or coherence_4_tetrodes_overtime_withfilter,
    available in Tetrode Analysis/analysis scripts. These make use of
    custom Coherence NEx templates, available in
    Tetrode Analysis/nex templates.

    ---Constructor Arguments---
    superfolder : str
        the master folder containing coherence data for a number of time bins
    hz_min : int, default 0
        the lower limit of frequencies for computing average coherence
    hz_max : int, default 100
        the upper limit of frequencies for computing average coherence
    band : str, default None
        brain wave oscillation band used to overwrite frequency arguments
    axis1 : list or range, default None
        denotes the wire numbers of rows to include, using 1-based rather than
        Python's 0-based indexing.
    axis2 : list or range, default None
        denotes the wire numbers of columns to include, using 1-based rather than
        Python's 0-based indexing.
    **kwargs : range, list, or instance of Region()
        kwargs with the structure 'reg_{region name}' can be passed to give names
        to wires, using 1-based indexing to identify wires.  Or, instances of
        Region() can be passed. Each regions wires will be named with the
        format '{region name} {#}'. Region kwargs can overwrite each other,
        with hierarchy based on the order they are passed.
        Regions() should be passed with an arbitrary keyword argument.


    ---Methods---
    fill_nan() : convert incomplete bins to mp.nan

    ---Attributes---
    data : the coherence data over time (list of DataFrames)
    superfolder : superfolder
    hz_min : hz_min
    hz_max : hz_max
    band : band
    axis1 : axis1
    axis2 : axis2
    kwargs : dict of all kwargs passed

    Additional attributes loaded from the 'info.csv' or 'movement.csv'
    generated by coherence_4_tetrodes_overtime.py:
    start : int (start time in seconds)
    end : int (end time in seconds)
    bin_length : int (duration of each time bin)
    interval : int (number of bins)
    movement : DataFrame (movement data, at raw frequency)
    """


    def __init__(self,
                 superfolder,
                 hz_min = 0,
                 hz_max = 100,
                 band = None,
                 axis1 = None,
                 axis2 = None,
                 **kwargs):
      """Loads the coherence data and initializes attributes"""

      self.superfolder = superfolder
      self.band = band
      self.hz_min = hz_min
      self.hz_max = hz_max
      self.axis1 = axis1
      self.axis2 = axis2
      self.data = []

      if band != None:
        self.hz_min = get_frequencies(band)[0]
        self.hz_max = get_frequencies(band)[1]

      if not os.path.isdir(superfolder):
        print('Error: Cannot find directory "' + superfolder + '".\n')
        sys.exit()

      print('----------\n')
      print('Trying to compute coherence data for "' + superfolder + '".\n')

      #gets the list of folders to work on
      #excludes the .csv files

      folderlist = [folder for folder in os.listdir(superfolder)
                    if os.path.isdir(os.path.join(superfolder,folder))]
      folderlist = natsort.natsorted(folderlist)

      first_path = os.path.join(superfolder, folderlist[0])
      wires = len(os.listdir(first_path))

      if self.axis1 == None:
          self.axis1 = range(1,wires)
      if self.axis2 == None:
          self.axis2 = self.axis1


      print('\nStarting loop:\n')

      for folder in folderlist:
        path = os.path.join(superfolder, folder)
        holder = Coherence_Matrix(path,
                                  freq_min = self.hz_min,
                                  freq_max = self.hz_max,
                                  rows = self.axis1,
                                  cols = self.axis2,
                                  **kwargs)
        band_matrix = holder.data

        self.data.append(band_matrix)
        print(path + " processed")
      print('\nLoop complete.\n')
      print('\nLooking for .csv files in ' + superfolder)

      if os.path.isfile(os.path.join(superfolder, 'info.csv')):
        info = pd.read_csv(os.path.join(superfolder, 'info.csv'))
        self.start = info['start'][0]
        self.end = info['end'][0]
        self.bin_length = info['bin length'][0]
        self.interval = info['# bins'][0]

        print('\nLoaded data from "info.csv"\n')
      else:
        print('\ninfo.csv not found\n')

      if os.path.isfile(os.path.join(superfolder, 'movement.csv')):
        self.movement = pd.read_csv(os.path.join(superfolder, 'movement.csv'))
        print('\nLoaded movement data from movement.csv\n')
      else:
        print('\nmovement.csv not found; movement data unavailable\n')

    def fill_nan(self, bin_key = 'default'):
        """
        Replace incomplete frames of data with np.nan using
        a 'bin_key.csv' file, generated when using
        coherence_4_tetrodes_overtime_withinterval.  After using fill_nan(),
        using coherence_line_plot() will omit missing data points.

        Parameters
        ----------
        bin_key : str, optional
            Path to the 'bin_key.csv' file.  If default, the function
            tries to find the file relative to the "superfolder"
            constructor argument.

        Returns
        -------
        None.

        """
        if bin_key != 'default':
            bin_key_path = bin_key
        else:
            bin_key_path = os.path.join(self.superfolder, 'bin_key.csv')
        bin_key_df = pd.read_csv(bin_key_path)
        for index, dataframe in enumerate(self.data):
            if not bin_key_df['complete'][index]:
                dataframe[:] = np.nan
        return

class Coherence_1D_Overtime():
    """
    Compute and load coherence matrices for multiple time bins.  Works like
    Coherence_Matrix_Overtime(), but uses Coherence_1D() and stores data
    as a DataFrame with each coherence value between wires as a column and
    each time point as a row.
        The directory should be a superfolder containing subfolders which
    each contain .csv files with "coherence matrices", i.e. a matrix of the
    coherence of LFPs between tetrode wires at different frequencies from
    0-100 Hz. There should be one .csv file for each reference wire, and
    one subfolder for each time bin.
        The desired directory can be generated by our NEx scripts, such as
    coherence_4_tetrodes_overtime or coherence_4_tetrodes_overtime_withfilter,
    available in Tetrode Analysis/analysis scripts. These make use of
    custom Coherence NEx templates, available in
    Tetrode Analysis/nex templates.

    ---Constructor Arguments---
    superfolder : str
        the master folder containing coherence data for a number of time bins
    hz_min : int, default 0
        the lower limit of frequencies for computing average coherence
    hz_max : int, default 100
        the upper limit of frequencies for computing average coherence
    band : str, default None
        brain wave oscillation band used to overwrite frequency arguments
    wirenames : list of Regions()
        instances of the Region class used to name wires; Regions should have
        equal axes and refer to one brain region
    **kwargs : instances of Region()
        Region() objects are used to slice the raw data.  They are used to
        choose which cells of a coherence matrix are added to the 1-dimensional
        DataFrame.  For each Region() "x" passed, the resulting 1-D
        DataFrame will include all wires marked by x.axis1 & x.axis.
        Regions() should be passed with an arbitrary keyword argument.

    ---Attributes---
    data : the coherence data over time, with each time point in 1D (DataFrame)
    superfolder : superfolder
    hz_min : hz_min
    hz_max : hz_max
    band : band
    wirenames : wirenames
    kwargs : dict of all kwargs passed

    Additional attributes loaded from the 'info.csv' or 'movement.csv'
    generated by coherence_4_tetrodes_overtime.py:
    start : int (start time in seconds)
    end : int (end time in seconds)
    bin_length : int (duration of each time bin)
    interval : int (number of bins)
    movement : DataFrame (movement data, at raw frequency)
    """
    def __init__(self,
                 superfolder,
                 band = None,
                 hz_min = 0,
                 hz_max = 100,
                 wirenames = None,
                 **kwargs):
      self.superfolder = superfolder
      self.band = band
      self.hz_min = hz_min
      self.hz_max = hz_max
      self.wirenames = wirenames
      self.data = []
      self.kwargs = {key : val for key, val in kwargs.items()}

      if band != None:
        self.hz_min = get_frequencies(band)[0]
        self.hz_max = get_frequencies(band)[1]

      if not os.path.isdir(superfolder):
        print('Error: Cannot find directory "' + superfolder + '".\n')
        sys.exit()

      print('----------\n')
      print('Trying to compute coherence data for "' + superfolder + '".\n')


      #gets the list of folders to work on
      #excludes the .csv files

      folderlist = [folder for folder in os.listdir(superfolder)
                    if os.path.isdir(os.path.join(superfolder,folder))]
      folderlist = natsort.natsorted(folderlist)

      print('\nStarting loop:\n')

      for folder in folderlist:
        path = os.path.join(superfolder, folder)
        holder = Coherence_1D(path,
                              freq_min=self.hz_min,
                              freq_max=self.hz_max,
                              wirenames = self.wirenames,
                              **kwargs)
        coherence_list = holder.data

        self.data.append(coherence_list)
        print(path + " processed")

      print("\nMerging data...")
      self.data = pd.concat(self.data, ignore_index = True)
      self.data.index.name = 'Frame'
      print('\nFinished!')

      print('\nLooking for .csv files in ' + superfolder)

      if os.path.isfile(os.path.join(superfolder, 'info.csv')):
        info = pd.read_csv(os.path.join(superfolder, 'info.csv'))
        self.start = info['start'][0]
        self.end = info['end'][0]
        self.bin_length = info['bin length'][0]
        self.interval = info['# bins'][0]

        new_index = []
        for val in range(len(self.data.index)):
          new_index.append(val*self.bin_length)

        self.data.index = new_index
        self.data.index.name = "Time (s)"

        print('\nLoaded data from "info.csv"\n')
      else:
        print('\ninfo.csv not found\n')

      if os.path.isfile(os.path.join(superfolder, 'movement.csv')):
        self.movement = pd.read_csv(os.path.join(superfolder, 'movement.csv'))
        print('\nLoaded movement data from movement.csv\n')
      else:
        print('\nmovement.csv not found; movement data unavailable\n')

class Coherence_PCA():
    """
    Class for running principal component analysis on coherence data,
    using scikit learn's PCA.

    Data is taken from an instance of Coherence_1D_Overtime.  The PCA
    constructs PCs for each time point, allowing one to view the movement
    through PC space over the course of the recording.  There are included
    methods for visualizing the data.

    ---Constructor Arguments---
    coherence_1d : Coherence_1D_Overtime
        coherence data loaded into a Coherence_1D_Overtime object
    PCs : int
        number of PCs to compute

    ---Attributes---
    data : DataFrame (PC values for each timepoint)
    explained_variance : DataFrame (explained variance ratios for the PCs)
    coherence_1d : coherence_1d
    PCs : PCs
    band : coherence_1d.band
    hz_min : coherence_1d.hz_min
    hz_max : coherence_1d.hz_max
    path : coherence_1d.superfolder

    ---Methods---
    scree_plot()
        show the explained variance ratios for each PC as a bar graph
    line_plot()
        plot PC1 vs PC2 for each time point as a matplotlib line plot
    heatmap()
        plot PC1 vs PC2 for each time point as a seaborn kdeplot
    animated_line_plot()
        plot PC1 vs PC2 for each time point as an animation

    """
    def __init__(self,
                 coherence_1d,
                 PCs):
        """
        Run the PCA and initialize attributes
        """

        self.coherence_1d = coherence_1d
        self.PCs = PCs
        self.band = coherence_1d.band
        self.hz_min = coherence_1d.hz_min
        self.hz_max = coherence_1d.hz_max
        self.path = coherence_1d.superfolder

        columns_headers = []
        for j in range(PCs):
            header = "PC" + str(j+1)
            columns_headers.append(header)

        pca = PCA(PCs)
        self.data = pd.DataFrame(pca.fit_transform(coherence_1d.data),
                            columns = columns_headers,
                            index = coherence_1d.data.index)

        #load explained variance, from Ilona
        columns_explained = []
        for j in range(10):
            header = "PC" + str(j+1) + "_variance_ratio"
            columns_explained.append(header)
        explained_arr = pca.explained_variance_ratio_
        explained = [el for el in explained_arr]
        data4dataframe = []
        for i in range(len(columns_explained)):
            data4dataframe.append(pd.DataFrame({columns_explained[i]:explained[i]}, index = [0]))
        self.explained_variance = pd.concat(data4dataframe, axis=1)

    def scree_plot(self):
        """Plot the explained variance ratio
        to save, use plt.savefig()"""
        fig, ax = plt.subplots(figsize = (10,10))
        bars =  [i[:3] for i in self.explained_variance.columns]
        data = self.explained_variance.iloc[0,:]
        ax.bar(bars, data)
        ax.set_ylim(0,1)
        ax.set_ylabel('Explained Variance Ratio')
        ax.set_xlabel('Principal Component')
        ax.set_title('Explained Variance Plot')
        return fig

    def line_plot(self, *args):
        """plot PC1 vs PC2 for each time point as a matplotlib line plot
        to save, use plt.savefig()

        Parameters
        ----------
        *args :
            Timeframe() objects used to plot different phases of the
            recording as separate lines
        """

        fig, ax = plt.subplots(figsize = (10,10))
        ax.set_ylabel('PC2')
        ax.set_xlabel('PC1')
        ax.set_title('PCA line plot')

        times = self.data.index.to_list()

        if args:
            for arg in args:
                if isinstance(arg, Timeframe):
                    start_index = min(times, key = lambda x: abs(x-arg.start_sec))
                    end_index = min(times, key = lambda x: abs(x-arg.end_sec))
                    pc1 = self.data.loc[start_index:end_index, 'PC1'].to_list()
                    pc2 = self.data.loc[start_index:end_index, 'PC2'].to_list()
                    ax.plot(pc1, pc2, color = arg.color, label = arg.name)
                    ax.text(pc1[0], pc2[0], 't = ' + str(start_index))
                    ax.text(pc1[-1], pc2[-1], 't = ' + str(end_index))
                    plt.legend()
        else:
            pc1 = self.data.loc[:, 'PC1'].to_list()
            pc2 = self.data.loc[:, 'PC2'].to_list()
            ax.plot(pc1, pc2)
            ax.text(pc1[0], pc2[0], 't = ' + str(times[0]))
            ax.text(pc1[-1], pc2[-1], 't = ' + str(times[-1]))
        return fig

    def heatmap(self, *args):
        """plot PC1 vs PC2 for each time point as a seaborn kdeplot.
        to save, use plt.savefig()

        Parameters
        ----------
        *args :
            Timeframe() objects used to plot different phases of the
            recording as separate contours
        """
        fig, ax = plt.subplots(figsize = (10,10))
        ax.set_ylabel('PC2')
        ax.set_xlabel('PC1')
        ax.set_title('PCA Heatmap')

        times = self.data.index.to_list()

        if args:
            for arg in args:
                if isinstance(arg, Timeframe):
                    start_index = min(times, key = lambda x: abs(x-arg.start_sec))
                    end_index = min(times, key = lambda x: abs(x-arg.end_sec))
                    pc1 = self.data.loc[start_index:end_index, 'PC1'].to_list()
                    pc2 = self.data.loc[start_index:end_index, 'PC2'].to_list()
                    sns.kdeplot(pc1,
                                pc2,
                                shade=True,
                                shade_lowest = False,
                                label=arg.name,
                                color = arg.color,
                                alpha = .75)
                    plt.legend()

        else:
            pc1 = self.data.loc[:, 'PC1'].to_list()
            pc2 = self.data.loc[:, 'PC2'].to_list()
            sns.kdeplot(pc1,
                        pc2,
                        shade=True,
                        shade_lowest = False)
        return fig

    def animated_line_plot(self, *args):
        """plot PC1 vs PC2 for each time point as a matplotlib line plot
        to save, use ani.save()

        Parameters
        ----------
        *args :
            Timeframe() objects used to plot different phases of the
            recording as separate lines
        """
        fig, ax = plt.subplots(figsize = (10,10))
        ax.set_ylabel('PC2')
        ax.set_xlabel('PC1')
        ax.set_title('animated PCA plot')

        times = self.data.index.to_list()

        plot_list = []
        data_lengths = []
        if args:
            for arg in args:
                if isinstance(arg, Timeframe):
                    plot_data = {}
                    start_index = min(times, key = lambda x: abs(x-arg.start_sec))
                    end_index = min(times, key = lambda x: abs(x-arg.end_sec))
                    pc1 = self.data.loc[start_index:end_index, 'PC1'].to_list()
                    pc2 = self.data.loc[start_index:end_index, 'PC2'].to_list()
                    time = [val for val in times if val >=start_index
                            if val <= end_index]
                    plot_data['pc1'] = pc1
                    plot_data['pc2'] = pc2
                    plot_data['time'] = time
                    plot_data['color'] = arg.color
                    plot_data['label'] = arg.name
                    plot_list.append(plot_data)
                    data_lengths.append(len(pc1))

            longest_data = max(data_lengths)
            for dict_ in plot_list:
                data_length = len(dict_['pc1'])
                for num in range(longest_data-data_length):
                    dict_['pc1'].append(dict_['pc1'][-1])
                    dict_['pc2'].append(dict_['pc2'][-1])
                    dict_['time'].append(dict_['time'][-1])

        else:
            plot_data = {}
            plot_data['pc1'] = self.data.loc[:, 'PC1'].to_list()
            plot_data['pc2'] = self.data.loc[:, 'PC2'].to_list()
            plot_data['label'] = 'all data'
            plot_data['color'] = 'black'
            plot_data['time'] = times
            plot_list.append(plot_data)

        plot_objects = []
        plot_objects2 = []
        pc1_mins = []
        pc1_maxs = []
        pc2_mins = []
        pc2_maxs = []
        for dict_ in plot_list:
            x = ax.plot(dict_['pc1'][0],
                        dict_['pc2'][0],
                        color = dict_['color'],
                        label = dict_['label'],)[0]
            y = ax.plot(dict_['pc1'][0],
                        dict_['pc2'][0],
                        color = dict_['color'],
                        alpha = .2)[0]

            plot_objects.append(x)
            plot_objects2.append(y)
            #also find minimum/max values
            pc1_mins.append(min(dict_['pc1']))
            pc1_maxs.append(max(dict_['pc1']))
            pc2_mins.append(min(dict_['pc2']))
            pc2_maxs.append(max(dict_['pc2']))
        plt.legend()
        pc1_min = min(pc1_mins)
        pc1_max = max(pc1_maxs)
        pc2_min = min(pc2_mins)
        pc2_max = max(pc2_maxs)
        pc1_buff = (pc1_max - pc1_min)*.1
        pc2_buff = (pc2_max - pc2_min)*.1

        ax.set_xlim(pc1_min - pc1_buff, pc1_max + pc1_buff)
        ax.set_ylim(pc2_min - pc2_buff, pc2_max + pc2_buff)

        def update(g):
            for line in range(len(plot_objects)):
                sec = plot_list[line]['time'][g]
                label = plot_list[line]['label'] + ' t=' + str(sec) + 's'
                plot_objects[line].set_label(label)
                plt.legend()
                plot_objects2[line].set_data(plot_list[line]['pc1'][:g],
                                                plot_list[line]['pc2'][:g])
                if g < 3:
                    plot_objects[line].set_data(plot_list[line]['pc1'][:g],
                                                plot_list[line]['pc2'][:g])
                else:
                    for line in range(len(plot_objects)):
                        plot_objects[line].set_data(plot_list[line]['pc1'][g-3:g],
                                                    plot_list[line]['pc2'][g-3:g])
            return plot_objects

        ani = animation.FuncAnimation(fig = fig,
                              func = update,
                              frames = range(len(plot_list[0]['time'])),
                              interval=150,
                              save_count=len(plot_list[0]['time']))

        return ani

class Region():
    """Class for marking wires by region name and color.

    ---Constructor Arguments---
    name : str
        Name of the region, used for plot labels or wire names
    axis1 : range or list
        denotes the wire numbers of rows marked by the region, using 1-based
        rather than Python's 0-based indexing.
    axis2 : range or list (default None)
        denotes the wire numbers of columns marked by the region, using
        1-based rather than Python's 0-based indexing.
    color : str (default "black")
        matplotlib color used when plotting wires from the region

    ---Attributes---
    name : name
    axis1 : axis1
    axis2 : axis2 (equal to axis1 if None)
    color : color
    """
    #using a class to have information associated with each region
    def __init__(self, name, axis1, axis2 = None, color = 'black'):
        """Translate axis arguments to 0-based, initialize attributes"""
        self.name = name
        self.axis1 = axis1
        self.color = color
        self.axis2 = axis2

        #format the axis arguments
        #traslating from 1-based indexing to 0-based
        if type(self.axis1) == list:
          #subtract 1 for every element in axis1
          if all(isinstance(x, int) for x in self.axis1):
            self.axis1 = [i-1 for i in axis1]
        elif type(self.axis1) == range:
          #also subtract 1, but then append one extra
          self.axis1 = [x-1 for x in self.axis1]
          self.axis1.append(self.axis1[-1]+1)

        if axis2 == None:
          self.axis2 = self.axis1

        else:
          if type(self.axis2) == list:
            if all(isinstance(x, int) for x in self.axis2):
              self.axis2 = [i-1 for i in axis2]
          elif type(self.axis2) == range:
            self.axis2 = [x-1 for x in self.axis2]
            self.axis2.append(self.axis2[-1]+1)

    def __repr__(self):
        return str({'name': self.name,
                'axis1': self.axis1,
                'axis2': self.axis2,
                'color': self.color})

    def __str__(self):
        return ("Region(name=" + self.name +
                ', axis1=' + str(self.axis1) +
                ', axis2=' + str(self.axis2) +
                ', color=' + self.color + ')')


class Timeframe():
    """Class for marking a time period in seconds

    ---Constructor Arguments---
    name : str
        name for the Timeframe
    start_sec : int
        start of the Timeframe (in seconds)
    end_sec : int
        end of the Timeframe (in seconds)
    color : str (default 'black')
        matplotlib color used when plotting the Timeframe

    ---Attributes---
    name : name
    start_sec : start_sec
    end_sec : end_sec
    color : color"""

    def __init__(self, name, start_sec, end_sec, color = 'black'):
        """Initialize attributes"""
        self.name = name
        self.start_sec = start_sec
        self.end_sec = end_sec
        self.color = color

    def __repr__(self):
        return str({'name': self.name,
                'start_sec': self.start_sec,
                'end_sec': self.end_sec,
                'color': self.color})

    def __str__(self):
        return ("Region(name=" + self.name +
                ', start_sec=' + str(self.start_sec) +
                ', end_sec=' + str(self.end_sec) +
                ', color=' + self.color + ')')

def coherence_plotter(folder,
                    graph_type,
                    folder2 = None,
                    order = 0,
                    savepath = 'default',
                    make_dir = True,
                    savename = 'default',
                    bands = None,
                    hz_min = None,
                    hz_max = None,
                    prompt = True,
                    saving = False,
                    axis1 = None,
                    axis2 = None,
                    classic = False,
                    allow_doubles = 'bottom',
                    user_title = None,
                    title_tag = False,
                    **kwargs):

  """
  Takes a directory full of coherence matrices and generates
  coherence plots for multiple bands quickly.  Rather than returning single
  figures, coherence_super_plotter() generates many plots and includes
  arguments for saving these.

  The directory should be a folder containing .csv files with
  'coherence matrices', i.e. a matrix of the coherence of LFPs between
  tetrode wires at different frequencies from 0-100 Hz. There should be one
  .csv file for each reference wire.

  The desired directory can be generated by our NEx scripts, such as
  coherence_4_tetrodes or coherence_4_tetrodes_withfilter, available in
  Tetrode Analysis/analysis scripts. These make use of custom Coherence NEx
  templates, available in drive/Tetrode Analysis/nex templates.

  ---Arguments---
  folder : str or iterable
    the file path of the directory, or a list of directories to average
  graph_type : str or list
    the type of graphs to create; 'matrix' will create a matrix heatmap, while
    'circle' will create a circle plot using MNE's plot_connectivity_circle
    (https://mne.tools/stable/generated/mne.viz.plot_connectivity_circle.html)
  folder2 : str, default None
    the file path of an optional second directory to use for subtracting
    coherence data
  order : int, default 0
    Determines how to subtract data when using two folders
        0: folder - folder2
        1: folder2 - folder
  savepath : str, default 'default'
    the file path of the directory to save in; a new folder with the plots
    is created at this path. calling 'default' will try to save plots on 1) a
    Google Colab folder ("Tetrode_Analysis/plots") or 2) the desktop
  make_dir : bool, default True
    if saving, whether or not to save the plots in a new folder or directly in
    `savepath`.  The latter is only recommended if you have already created a
    new directory to save the plots in.  The reason for this is that plots are
    saved with non-unique names, so new graphs of the same type will overwrite
    old ones.  With a new save folder,there is extra information to identify
    the graphs, and overwriting isn't an issue.
  savename : str, default 'default'
    the name to give to the new folder where plots will be saved; if 'default',
    the folder name will be created based on the input directory and a
    timestamp.  Only used if `make_dir` = True (default)
  bands : str or list, default None
    the brain oscillation bands to use for analysis, if specific frequencies
    are not specified (if hz_min and hz_max are specified, this argument will
    be ignored) possible values are 'delta' (0-4 Hz), 'theta' (4-8 Hz),
    'alpha' (8-12 Hz), 'beta' (12-30 Hz), 'gamma' (30-100 Hz), and 'all';
    'all' makes graphs for all 5 bands. If neither the bands nor the
    hz_min/hz_max arguments are set, analysis defaults to 0-100 Hz.
  hz_min : int, default None
    the lower limit of frequencies for plotting
  hz_max : int, default None
    the upper limit of frequencies for plotting
  prompt : bool, default True
    verifies the graph conditions with the user before running
  saving : bool, default False
    whether or not to save graphs; can still be interrpted by the prompt
    argument
  axis1 : list or range, default None
    denotes the wire numbers to graph as rows, using 1-based rather than
    Python's 0-based indexing.
  axis2 : list or range, default None
    denotes the wire numbers to graph as rows, using 1-based rather than
    Python's 0-based indexing.
  classic : bool, default False
    renders the graphs with classic formats
    (not recommended when performing subtraction)
    - matrix: white background, colormap = 'plasma'
    - circle: black background, colormap = 'hot'
  allow_doubles : str, default 'top'
    handles plotting of possible duplicate connections for circle plots with
    non-equal axis arguments
    -'bottom': only plot connections below diagonal of complete matrix
    -'top': only plot connections above diagonal of complete matrix
    -'all': plot all connections, allowing duplicate connections
    as coherence data is symmetrical, 'bottom' and 'top' should result
    in the same graph
  user_title : str, default None
    title to set, which will be given to all graphs
  title_tag : bool, default False
    subtitle corresponding to the frequencies used, can be added
    when passing a 'user_title'
  **kwargs : range, list, or instance of Region()
    kwargs with the structure 'reg_{region name}' can be passed to give
    names to wires, using 1-based indexing to identify wires.  Or,
    instances of Region() can be passed. Each regions wires will be named
    with the format '{region name} {#}'. Region kwargs can overwrite
    each other, with hierarchy based on the order they are passed.
    Regions() should be passed with an arbitrary keyword argument.
  ---------------

  Written by Tom Earnest
  January 2020
  earnestt1234@gmail.com
  """

  #################
  #Checks/warnings#
  #################

  #makes sure the directories exist, also records if subtraction/averaging is being done
  subtract = False
  average = False

  if isinstance(folder, str):
      if not os.path.isdir(folder):
        print("Stopping: cannot find '" + folder +  "'.  Please check the folder argument.")
        sys.exit()
  else:
      for path in folder:
          if not os.path.isdir(path):
              print("Stopping: cannot find '" + path +  "'.  Please check the folder argument.")
              sys.exit()
          else:
              average=True

  if saving == True:
      if savepath == 'default':
        if os.path.isdir(r"/content/drive/My Drive/Tetrode_Analysis/plots"):
          savepath = r"/content/drive/My Drive/Tetrode_Analysis/plots"
        else:
            try:
              desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')
              savepath = desktop
            except:
                print('Stopping: cannot find a default savepath; please specify' +
                      ' the "savepath" argument.')
                sys.exit()

  if saving == True:
    if not os.path.isdir(savepath):
      print("Stopping: cannot find '" + savepath +  "'.  Please check the savepath argument.")
      sys.exit()
  if folder2 != None:
    if not os.path.isdir(folder2):
      print("Stopping: cannot find '" + folder2 +  "'.  Please check the folder2 argument.")
      sys.exit()
    elif os.path.isdir(folder2):
      subtract = True

  #checks the order argument
  if order not in [0,1]:
    print("Stopping: order must be 0 or 1")
    sys.exit()

  #checks the graph_type arguments
  acceptable_graphs = ['circle', 'matrix']

  if type(graph_type) == list:
    for i in graph_type:
      if i not in acceptable_graphs:
        print('Stopping: only acceptable graph_type list is ["circle","matrix"]')
        sys.exit()
    if len(graph_type) >2:
      print('Stopping: only acceptable graph_type list is ["circle","matrix"]')
      sys.exit()

  elif type(graph_type) == str:
    if graph_type not in acceptable_graphs:
      print("Stopping: " + graph_type + " not recognized as a graph_type.  Please enter either 'circle' or 'matrix'.")
      sys.exit()
    graph_type = [graph_type]

  #checks the frequency/bands arguments and sets the limits for analysis
  acceptable_bands = ['delta', 'theta', 'alpha', 'beta', 'gamma', 'all']

  if hz_min != None and hz_max != None:
    bands = None
    if hz_min >= hz_max:
      print("Stopping: the lower frequency limit must be smaller than the higher frequency limit.")
      sys.exit()
    if hz_min < 0:
      print("Warning: the minimum frequency is out of bounds.  Running analysis for frequencies above 0.")
      hz_min = 0
    if hz_max > 100:
      print("Warning: the maximum frequency is out of bounds.  Running analysis for frequencies below 100.")
      hz_max = 100
    bands = ['unique band']
  elif (hz_min == None and hz_max != None) or (hz_min != None and hz_max == None):
    print('Stopping: both hz_min and hz_max arguments must be provided')
    return
  elif hz_min == None and hz_max == None:
    if type(bands) == str:
      if bands not in acceptable_bands:
        print("Stopping: bands argument not recognized.  Use any of ['delta', 'theta', 'alpha', 'beta', 'gamma', 'all'].")
        return
      if bands == 'all':
        bands = ['delta', 'theta', 'alpha', 'beta', 'gamma']
      else:
        bands = [bands]
    elif type(bands) == list:
      bands = list(set(bands))
      for i in bands:
        if i not in acceptable_bands:
          print("Stopping: bands argument not recognized.  Use any of ['delta', 'theta', 'alpha', 'beta', 'gamma', 'all'].")
          return
      if 'all' in bands:
        bands = ['delta', 'theta', 'alpha', 'beta', 'gamma']

    if bands == None:
      print("Stopping: no frequency arguments (bands / hz_min & hz_max) were provided.")
      return

  #check the allow_doubles argument
  if allow_doubles not in ['top', 'bottom', 'all']:
    print('\nStopping, "allow_doubles" must be "top", "bottom", or "all"')
    return

  #forces the title to be a string
  if user_title != None:
    try:
      user_title = str(user_title)
    except:
      print('\nStopping, problem with the "user_title" argument')
      return

  #establish axis arguments:
  if not average:
      axis_count_folder = folder
  else:
      axis_count_folder = folder[0]

  if axis1 == None:
    num = len(os.listdir(axis_count_folder))
    axis1 = range(1,num)
  if axis2 == None:
    axis2 = axis1

  #####################
  #Planning the graphs#
  #####################

  #makes a list of graphs to make
  #specified by the type and band
  graph_list = []
  for i in graph_type:
    for j in bands:
      graph_list.append((j,i))

  #creates default save folder names,
  #different for subtracted and non-subtracted plots
  if saving == True:
      if savename == 'default':
        if not subtract:
          if not average:
            name = os.path.basename(os.path.normpath(folder))
          elif average:
            name = 'averaged'
          timestamp = str(datetime.datetime.now()).replace(':',"_")
          savename = name + ' coherence plots ' + timestamp
        elif subtract:
          savename = 'subtracted coherence plots ' + str(datetime.datetime.now())

  #forces name of saving folder to be unique
  g = 1
  saveto = savename
  while os.path.exists(os.path.join(savepath, saveto)):
      saveto = savename + " " + str(g)
      g+=1

  savename = saveto

  #always goes ahead if prompt == False
  if prompt == False:
    proceed = 'y'

  #creates the written prompt if prompt == True
  if prompt == True:
    #changing prompt to reflect averaging
    if not average:
      prompt_readout = folder
    elif average:
      prompt_readout = '[multiple folders, see below]'

    #signal if there is an issue with a combination
    #of canonical and user-specified bands
    notice = False
    if not subtract:
      print('----------\n\nGraphs to make for the directory "'  + prompt_readout + '":\n')
    elif subtract:
      if order == 0:
        print('----------\n\nGraphs to make for the directories:\n\n"'  + prompt_readout
              + '"\n MINUS \n"' + folder2 + '":\n')
      elif order == 1:
        print('----------\n\nGraphs to make for the directories:\n\n"'  + folder2
              + '"\n MINUS \n"' + prompt_readout + '":\n')
    for i in graph_list:
      print('    ',i[0], i[1], 'plot')
      if i[0] == 'unique band':
        notice = True
        print('     (band from ' + str(hz_min) + ' to ' + str(hz_max) + ' Hz)')
    if notice:
      print("""\nNote: coherence_plots() currently does not support the plotting of multiple
      unique band frequencies, or the combination of user-specified and canonical frequencies.
      To plot multiple user-specified frequency bands, you can contruct a for loop, iterating
      over different frequencies.""")

    if saving == False:
      print('\nPlots will not be saved!')
    elif saving == True:
      if make_dir == True:
        print('\nSaving plots at "' + savepath + '" in a new folder, "' + savename + '".')
      elif make_dir == False:
        print('\nSaving plots directly at "' + savepath + '". Existing plots may be overwritten!')

    if user_title != None:
      if title_tag == False:
        print('\nAll graphs will have the title "' + user_title + '".')
      elif title_tag == True:
        print('\nAll graphs will have the title "' + user_title + '", plus a tag showing the band used.')

    if average:
      print('\n[multiple folders]: coherence data for the following folders will be averaged:')
      for path in folder:
        print('     ' + path)

    for i in kwargs:
      if i[:4] != 'reg_' and not isinstance(kwargs[i], Region):
        print("\nWARNING: some kwargs not recognized; please check extra arguments")

    print('\n----------\n')
    proceed = input('Proceed?  Enter "y" or "n".\n')

  ##############
  #Making plots#
  ##############

  #makes sure user said go ahead
  if proceed != 'n' and proceed !='y':
    print("Command not recognized.")
    return

  if proceed == 'n':
    return

  #relates band names to certain frequencies
  band_dict = {'delta' : (0,4),
                'theta' : (4,8),
                'alpha' : (8,12),
                'beta'  : (12,30),
                'gamma' : (30,100),
                'unique band' : (hz_min, hz_max)}


  #makes a folder if saving/make_dir is on
  if saving == True:
    if make_dir == True:
      os.mkdir(os.path.join(savepath,savename))
      saveto = os.path.join(savepath,savename)
    elif make_dir == False:
      saveto = savepath

  #setting the class to use based on averaging:
  if average:
    coherence_class = Coherence_Matrix_Average
  else:
    coherence_class = Coherence_Matrix

  #constructing the data to plot
  for band in bands:

    #either compute inside_coherence for folder
    if not subtract:
      holder = coherence_class(folder,
                                band_dict[band][0],
                                band_dict[band][1],
                                rows = axis1,
                                cols = axis2,
                                **kwargs)
      band_matrix = holder.data
      lower = holder.freq_min
      upper = holder.freq_max

    #or do for both folder and folder2, and then subtract
    #with the order specified by 'order' argument
    elif subtract:
      holder1_ = coherence_class(folder,
                                band_dict[band][0],
                                band_dict[band][1],
                                rows = axis1,
                                cols = axis2,
                                **kwargs)
      data1 = holder1_.data
      lower = holder1_.freq_min
      upper = holder1_.freq_max

      holder2_ = Coherence_Matrix(folder2,
                                band_dict[band][0],
                                band_dict[band][1],
                                rows = axis1,
                                cols = axis2,
                                **kwargs)
      data2 = holder2_.data
      if order == 0:
        band_matrix = data1-data2
      elif order == 1:
        band_matrix = data2-data1

    #making default title, range settings:
    if not average:
      title_str = folder
    else:
      title_str = 'multiple folders (averaged)'
    if not subtract:
      title = (os.path.basename(os.path.normpath(title_str)) + '\n' +
               str(band) + " (" + str(lower) + "-" +
               str(upper) + " Hz) coherence")
      vmin = 0
      vmax = 1
    elif subtract:
      if order == 0:
        title = (os.path.basename(os.path.normpath(title_str)) + " - " +
           os.path.basename(os.path.normpath(folder2)) + '\n' +
           str(band) + " (" + str(lower) + "-" +
           str(upper) + " Hz) coherence")
      elif order == 1:
        title = (os.path.basename(os.path.normpath(folder2)) + " - " +
           os.path.basename(os.path.normpath(title_str)) + '\n' +
           str(band) + " (" + str(lower) + "-" +
           str(upper) + " Hz) coherence")
      vmin = -1
      vmax = 1

    #overwriting default title if given
    if user_title != None:
      if title_tag:
        title = (user_title + '\n' + str(band) + " (" + str(lower) + "-" +
               str(upper) + " Hz) coherence")
      else:
        title =  user_title

    #making color settings
    if classic:
      mat_cmap = 'plasma'
      cir_cmap = 'hot'
      cir_background = 'black'
      cir_text = 'white'
    elif not classic:
      if not subtract:
        mat_cmap = 'plasma'
        cir_cmap = 'Reds'
        cir_background = 'white'
        cir_text = 'black'
      elif subtract:
        mat_cmap = 'bwr'
        cir_cmap = 'bwr'
        cir_background = 'white'
        cir_text = 'black'

    #graphing
    for graph in graph_type:
      if graph == 'matrix':

        #sets up the axes for the figure
        fig1, ax1 = plt.subplots(figsize=(7,7))
        plt.tight_layout()

        #makes the matrix plot, specifies tick distance according to the matrix length,
        #sets labels according to the FP names, makes a plot title, adds a colorbar

        plot1 = ax1.matshow(band_matrix, cmap = mat_cmap, vmin = vmin, vmax = vmax)
        ax1.set_xticks(np.arange(len(band_matrix.columns)))
        ax1.set_yticks(np.arange(len(band_matrix.index)))
        ax1.set_ylim(len(band_matrix.index)-0.5, -0.5) #see this bug: https://github.com/matplotlib/matplotlib/issues/14751
        ax1.set_xticklabels(band_matrix.columns, ha='left')
        ax1.set_yticklabels(band_matrix.index.values)
        ax1.tick_params('x', labelrotation = 45)
        ax1.set_title(title, fontsize=20, pad = 20)
        ax1.figure.colorbar(plot1, ax = ax1, cax = fig1.add_axes([1,
                                                                  .3,
                                                                  0.03,
                                                                  0.38]))

        if saving == True:
          plot_title = band + " " + graph + '.png'
          fig1.savefig(os.path.join(saveto, plot_title), dpi = 300, bbox_inches = 'tight')
          print("\n saved plot at " + saveto)

      if graph == 'circle':
        #determines whether axises are even or uneven for circle plotting

        #if they are equivalent, the whole matrix is passed
        #to plot_connectivity_circle as is
        if axis1 == axis2:
          cir_data = band_matrix
          indices = None
          nodes = band_matrix.columns

        #if not equivalent, extra processing must be done
        elif axis1 != axis2:
          convert_dict = circleplot_matrix_to_1d(band_matrix,
                                                 handledoubles=allow_doubles)
          cir_data = convert_dict['cir_data']
          indices = convert_dict['indices']
          nodes = convert_dict['nodes']

        #establishes the figure, using the function from MNE
        fig2 = plt.figure(figsize=(10,10), facecolor=cir_background)
        plt.tight_layout()
        circle = plot_connectivity_circle(np.array(cir_data),
                                          node_names=nodes,
                                          facecolor=cir_background,
                                          fig = fig2,
                                          fontsize_names=10,
                                          colorbar_size=.2,
                                          fontsize_colorbar=10,
                                          linewidth=1,
                                          vmin = vmin,
                                          vmax = vmax,
                                          title = title,
                                          fontsize_title = 20,
                                          colormap = cir_cmap,
                                          textcolor = cir_text,
                                          indices = indices)[0]
        if saving == True:
          plot_title = band + " " + graph + '.png'
          fig2.savefig(os.path.join(saveto, plot_title), dpi = 300, facecolor=cir_background, bbox_inches = 'tight')
          print("\n saved plot at " + saveto)

def coherence_line_plot(coherence_mat_overtime,
                        include_mvmt = False,
                        find_region_names = None,
                        find_between_regions = False,
                        find_within_regions = False,
                        find_region_printout = False,
                        **kwargs,):
    """
    plots coherence data overtime on a line plot

    Parameters
    ----------
    coherence_mat_overtime : instance of Coherence_Matrix_Overtime
        coherence data over multiple time points loaded into an
        object using Coherence_Matrix_Overtime()
    include_mvmt : bool, default False
        include a subgraph showing movement, taken from a 'movement.csv'
    **kwargs : Regions
        instances of Region() used to define wires to plot

    Returns
    -------
    either a matplotlib figure or a DataFrame of the data to plot

    """
    #checks/warnings:
    assert isinstance(coherence_mat_overtime, Coherence_Matrix_Overtime), (
        '"coherence_mat_overtime" must be an instance of '
        '"Coherence_Matrix_Overtime')
    assert isinstance(include_mvmt, bool), ('"include_mvmt" must be bool')
    if include_mvmt:
        if not isinstance(coherence_mat_overtime.movement, pd.DataFrame):
            print("\nCannot find movement data associated with your object.")
            print("\nPlotting without movement.")
            include_mvmt = False
        else:
            movement_df = coherence_mat_overtime.movement

    if find_region_names != None:
        try:
            found_regions = find_regions(df=coherence_mat_overtime.data[0],
                                         region_names=find_region_names,
                                         between_regions=find_between_regions,
                                         within_regions=find_within_regions,
                                         printout=find_region_printout)
            if len(found_regions) == 0:
                raise Exception()
            for i, reg in enumerate(found_regions):
                kwargs['found region ' + str(i)] = reg
        except:
            print("""Warning: "find_regions" did not work. Possible errors:
                  - More than 10 lines are being plotted
                  - The data are not evenly splittable into the region names passed
                  - The data are not equal in rows/columns
                  - There are an odd number of columns or rows""")

    #making the line plot when movement isn't included
    if not include_mvmt:

        #the seaborn style is a little nicer than the default matplot
        plt.style.use('seaborn-whitegrid')
        fig, ax = plt.subplots(figsize = (10,10))

        #construct the x coordinates
        #using the extra variables from the 'info.csv' file
        #xs are the starts of each bin
        xs = []
        for i in range(len(coherence_mat_overtime.data)):
            xs.append(coherence_mat_overtime.start +
                      i*coherence_mat_overtime.bin_length)

        #create a default all region if no kwargs passed
        if not kwargs:
            kwargs = {}
            example_data = coherence_mat_overtime.data[0]
            rows = len(example_data.index)
            cols = len(example_data.columns)
            kwargs['alldata'] = Region(None,
                                       range(1,rows),
                                       range(1,cols))

        #loop over the list of regions
        for k in kwargs:
            #empty list to house y data
            ys = []
            #for every frame of data
            for j in range(len(coherence_mat_overtime.data)):
              #add the the mean of all cells corresponding to the region's axes
              ys.append(coherence_mat_overtime.data[j].iloc[kwargs[k].axis1,kwargs[k].axis2].mean().mean())

            #plot a line for each region, same xs, different ys, colors, labels
            lineplot = plt.plot(xs, ys,
                                figure = fig,
                                color = kwargs[k].color,
                                label = kwargs[k].name)
        plt.legend()
        plt.xlim(min(xs),max(xs))
        plt.ylim(0,1)
        plt.xlabel('time (s)')
        plt.ylabel('coherence')
        if coherence_mat_overtime.band:
            plt.title('Coherence Line Plot\nband = ' +
                       coherence_mat_overtime.band)
        else:
            plt.title('Coherence Line Plot')

    elif include_mvmt:
        #the seaborn style is a little nicer than the default matplot
        plt.style.use('seaborn-whitegrid')
        fig, ax = plt.subplots(2,1, figsize = (10,15), gridspec_kw={'height_ratios': [3, 1]})

        #construct the x coordinates
        #using the extra variables from the 'info.csv' file
        #xs are the starts of each bin
        xs = []
        for i in range(len(coherence_mat_overtime.data)):
            xs.append(coherence_mat_overtime.start +
                      i*coherence_mat_overtime.bin_length)

        #loop over the list of regions
        for k in kwargs:
            #empty list to house y data
            ys = []
            #for every frame of data
            for j in range(len(coherence_mat_overtime.data)):
              #add the the mean of all cells corresponding to the region's axes
              ys.append(coherence_mat_overtime.data[j].iloc[kwargs[k].axis1,kwargs[k].axis2].mean().mean())

            #plot a line for each region, same xs, different ys, colors, labels
            ax[0].plot(xs, ys,
                       figure = fig,
                       color = kwargs[k].color,
                       label = kwargs[k].name)
        ax[0].legend()
        ax[0].set_xlabel('time (s)')
        ax[0].set_ylabel('coherence')
        if coherence_mat_overtime.band:
            ax[0].set_title('Coherence Line Plot\nband = ' +
                            coherence_mat_overtime.band)
        else:
            ax[0].set_title('Coherence Line Plot')
        ax[0].set_xlim(min(xs),max(xs))
        ax[0].set_ylim(0,1)

        #plot the movement data
        ax[1].plot(movement_df['time'], movement_df['motion'], color = 'black')
        ax[1].set_xlabel('time(s)')
        ax[1].set_ylabel('Motion')
        ax[1].set_title("Motion")
        ax[1].set_xlim(0,max(xs))

    return fig

def coherence_line_df(coherence_mat_overtime,
                      find_region_names = None,
                      find_between_regions = False,
                      find_within_regions = False,
                      find_region_printout = False,
                      **kwargs):
    """
    returns data from an instance of Coherence_Matrix_Overtime as a DataFrame
    essentially returns the data that would be plotted if using
    "coherence_line_plot()"

    Parameters
    ----------
    coherence_mat_overtime : instance of Coherence_Matrix_Overtime
        coherence data over multiple time points loaded into an
        object using Coherence_Matrix_Overtime()
    **kwargs : Regions
        instances of Region() used to define wires to make columns

    Returns
    -------
    DataFrame
    """
    assert isinstance(coherence_mat_overtime, Coherence_Matrix_Overtime), (
        '"coherence_mat_overtime" must be an instance of '
        '"Coherence_Matrix_Overtime')

    if find_region_names != None:
        try:
            found_regions = find_regions(df=coherence_mat_overtime.data[0],
                                         region_names=find_region_names,
                                         between_regions=find_between_regions,
                                         within_regions=find_within_regions,
                                         printout=find_region_printout)
            if len(found_regions) == 0:
                raise Exception()
            for i, reg in enumerate(found_regions):
                kwargs['found region ' + str(i)] = reg
        except:
            print("""Warning: "find_regions" did not work. Possible errors:
                  - More than 10 lines are being plotted
                  - The data are not evenly splittable into the region names passed
                  - The data are not equal in rows/columns
                  - There are an odd number of columns or rows""")

    output = pd.DataFrame()
    xs = []
    for i in range(len(coherence_mat_overtime.data)):
        xs.append(coherence_mat_overtime.start +
                  i*coherence_mat_overtime.bin_length)
    output['Time (s)'] = xs
    #create a default all region if no kwargs passed
    if not kwargs:
        kwargs = {}
        example_data = coherence_mat_overtime.data[0]
        rows = len(example_data.index)
        cols = len(example_data.columns)
        kwargs['alldata'] = Region('All wires',
                                   range(1,rows),
                                   range(1,cols))
    for k in kwargs:
        if isinstance(kwargs[k], Region):
            if coherence_mat_overtime.band:
                colname = (kwargs[k].name + " (" + coherence_mat_overtime.band +
                           ")")
            else:
                colname = kwargs[k].name
            ys = []
            #for every frame of data
            for j in range(len(coherence_mat_overtime.data)):
                #add the the mean of all cells corresponding to the region's axes
                ys.append(coherence_mat_overtime.data[j].iloc[kwargs[k].axis1,kwargs[k].axis2].mean().mean())
            output[colname] = ys

    return output

def animated_coherence_plot(coherence_matrix_overtime,
                            graph = 'matrix',
                            vmin = 0,
                            vmax = 1,
                            cmap = 'default',
                            classic = False,
                            allow_doubles = 'top'):
    """
    makes an animated coherence plot for a given folder or dataset

    SAVING:, use ani.save('plotname.gif', dpi = 300) (recommended)
    if classic == True, you will need to pass the following when saving in
    order to keep the black background throught the figure:
        ani.save('plot.gif', dpi = 300, savefig_kwargs={'facecolor':'black'})

    Parameters
    ----------
    obj : Coherence_Matrix_Overtime object
      An instance of "Coherence_Matrix_Overtime", e.g.:
        x = Coherence_Matrix_Overtime(/some/folder/, addtional arguments)
      x becomes an object which contains the data to plot, plus other associated
      values (like the bin size and number of bins) useful for plotting

    graph : str, default 'matrix'
      Type of graph, can be 'matrix' or 'circle'
    vmin : int or flt, default 0
      the lower limit of the colorbar (set automatically if not specified)
    vmax : int or flt, default 1
      the upper limit of the colorbar (set automatically if not specified)
    cmap : str, default "default"
     matplotlib color map to use for the graph; defaults to "plasma"
     for matrix and "Reds" for circle
    classic : bool, default False
     render circle plots with black background and colormap = 'hot'
     see note above about saving

    Returns
    -------
    Matplotlib animation

    """
    #lazy fix to change name
    obj = coherence_matrix_overtime

    #checks and warnings
    if not isinstance(obj, Coherence_Matrix_Overtime):
      print("Stopping: 'obj' must be instance of Coherence_Matrix_Overtime")
      sys.exit()

    if graph not in ['circle', 'matrix']:
      print('Stopping:, "graph" must be "circle" or "matrix".')
      sys.exit()

    if not (vmin < vmax):
      print('Stopping: "vmin" must be less than "vmax"')
      sys.exit()

    if cmap == 'default':
      mat_cmap = 'plasma'
      cir_cmap = 'Reds'

    background = 'white'
    textcolor = 'black'
    if classic == True:
      background = 'black'
      cir_cmap = 'hot'
      textcolor = 'white'

    if cmap != 'default':
      mat_cmap = cmap
      cir_cmap = cmap

    #plotting

    if graph == 'matrix':
      #initializing the matrix plot, setting most of the parameters that will be constant for each graph
      frame = obj.data[0]

      plt.rcParams["axes.grid"] = False
      fig, ax = plt.subplots(figsize=(10,10))
      plt.tight_layout()
      plt.subplots_adjust(left = .2, top = .8, right = .8, bottom = .2)
      mat = ax.matshow(frame, cmap = mat_cmap, vmin = vmin, vmax = vmax)
      ax.set_xticks(np.arange(len(frame.columns)))
      ax.set_yticks(np.arange(len(frame.index)))
      ax.set_xticklabels(frame.columns, ha='left')
      ax.set_yticklabels(frame.index)
      ax.set_ylim(len(frame.index)-0.5, -0.5)
      ax.tick_params('x', labelrotation = 45)
      ax.figure.colorbar(mat, ax = ax)

      #defines the way in which the graph is updated
      #see notes on the animation.FuncAnmation part below
      def update(g):
          mat.set_data(obj.data[g])
          ax.set_title(("frame " + str(g+1) + '\n' + str(obj.start + g*obj.bin_length) +
                        '-' + str(obj.start + (g+1)*obj.bin_length) + " seconds"),
                       fontsize=20, pad = 20)
          return mat

      #defines the animation

      #fig is the figure on which to draw the animation - this is set in fig, ax = plt.subplots(...) above

      #frames defines what data goes into each frame.
      #frames is iterated over and passed into the func argument (update() in our case)
      #here, we use the indexes of matlist (the list containing the coherence matrix for each analysis bin)
      #this allows us to pass an index into the update() function, in which we can then select the appropriate data
      #as well as using the index for titles

      #func is the function which determines how to update the plot each frame
      #here, update() changes the data to the next matrix of data in matlist, and sets the title appropriately

      ani = animation.FuncAnimation(fig = fig,
                                    frames = list(range(len(obj.data))),
                                    func = update,
                                    interval=200, save_count=len(obj.data)
                                   )

      plt.show()

    elif graph == 'circle':
        fig2 = plt.figure(figsize=(15,15), facecolor=background)

        if list(obj.data[0].columns) != list(obj.data[0].index):
            new_data = []
            for num, frame in enumerate(obj.data):
                convert_dict = circleplot_matrix_to_1d(frame,
                                                        handledoubles = allow_doubles)
                new_data.append(convert_dict['cir_data'])
                if num == 0:
                    indices = convert_dict['indices']
                    nodes = convert_dict['nodes']
            plotting = new_data
        else:
            indices = None
            nodes = list(obj.data[0].columns)
            plotting = obj.data

        def update(g):
            fig2.clear()
            circle = plot_connectivity_circle(np.array(plotting[g]),
                                              node_names=nodes,
                                              indices = indices,
                                              facecolor=background,
                                              textcolor = textcolor,
                                              colormap = cir_cmap,
                                              fig = fig2,
                                              fontsize_names=15,
                                              colorbar_size=.4,
                                              fontsize_colorbar=15,
                                              linewidth=2,
                                              vmin = 0,
                                              vmax = 1,
                                              title = ("frame " + str(g+1) + '\n' +
                                                       str(obj.start + g*obj.bin_length)
                                                       + '-' + str(obj.start +
                                                                   (g+1)*obj.bin_length)
                                                       + " seconds"),
                                              fontsize_title = 30,
                                              show = False)[0]
            return circle

        ani = animation.FuncAnimation(fig2, update, list(range(len(obj.data))),
                                      interval=200, save_count=len(obj.data))

    return ani

def get_frequencies(band):
  """
  takes a string and returns associated brain wave oscillation frequencies,
  if any

  Parameters
  ----------
  band : str
    lowercase string name of band

  Returns
  -------
  tuple
    two-element tuple containing the lower and upper frequency
  """
  band_dict = {'delta' : (0,4),
               'theta' : (4,8),
               'alpha' : (8,12),
               'beta'  : (12,30),
               'gamma' : (30,100),}

  assert band in band_dict, ('"' + str(band) + '" not recognized as a band.')
  return band_dict[band]

def circleplot_matrix_to_1d(matrix, handledoubles = 'bottom'):
    """
    process a non-square matrix for plotting with
    mne.plot_connectivity_circle()

    Parameters
    ----------
    matrix : DataFrame
        Matrix to process
    handledoubles : str (default 'bottom')
        -'bottom': only plot connections below diagonal of complete matrix
        -'top': only plot connections above diagonal of complete matrix
        -'all': plot all connections, allowing duplicate connections
        as coherence data is symmetrical, 'bottom' and 'top' should result
        in the same graph

    Returns
    -------
    a dictionary:
        {'cir_data' : one-dimensional data to plot,
         'indices' : tuple of indexes to pass to 'inidces' argument,
         'nodes' : node names to pass to the 'node_names' argument,}

    """
    band_matrix_1d = matrix.stack().tolist()
    nodes =  list(np.unique(list(matrix.columns) + list(matrix.index)))

    nodes_dict = {}
    for i in range(len(nodes)):
        nodes_dict[nodes[i]] = i

    #build indices to associate with each data point
    ind1 = []
    ind2 = []
    for row in matrix.index:
        for col in matrix.columns:
            ind1.append(nodes_dict[col])
            ind2.append(nodes_dict[row])
    #remove self-self connections
    self_cons = [i for i in range(len(ind1)) if ind1[i] != ind2[i]]
    band_matrix_1d = np.array([band_matrix_1d[i] for i in self_cons])
    ind1 = np.array([ind1[i] for i in self_cons])
    ind2 = np.array([ind2[i] for i in self_cons])

    #handle removal of duplicates, first name all the pairs
    ind_pairs = [set(pair) for pair in list(zip(ind1,ind2))]

    #no changes if duplicates are allowed
    if handledoubles == 'all':
      pass

    elif handledoubles == 'top':
      repeat_cons = []
      for i in range(len(ind_pairs))[::-1]:
          if ind_pairs[i] in ind_pairs[:i]:
              repeat_cons.append(i)
      band_matrix_1d = np.array([band_matrix_1d[i] for i in range(len(band_matrix_1d)) if i not in repeat_cons])
      ind1 = np.array([ind1[i] for i in range(len(ind1)) if i not in repeat_cons])
      ind2 = np.array([ind2[i] for i in range(len(ind2)) if i not in repeat_cons])

    #plot only bottom duplicates
    elif handledoubles == 'bottom':
      repeat_cons = []
      for i in range(len(ind_pairs)-1):
          if ind_pairs[i] in ind_pairs[i+1:]:
              repeat_cons.append(i)
      band_matrix_1d = np.array([band_matrix_1d[i] for i in range(len(band_matrix_1d)) if i not in repeat_cons])
      ind1 = np.array([ind1[i] for i in range(len(ind1)) if i not in repeat_cons])
      ind2 = np.array([ind2[i] for i in range(len(ind2)) if i not in repeat_cons])

    cir_data = band_matrix_1d
    indices = (ind1, ind2)
    nodes = nodes

    return {'cir_data' : cir_data,
            'indices' : indices,
            'nodes' : nodes}

def find_regions(df,
                 region_names,
                 between_regions=True,
                 within_regions=False,
                 printout = False):
    """
    Try to automatically create Region() objects (both between and within
    brain regions) for a coherence matrix, given a list of region names.
    For this function to work, some assumptions must be met:
        -the data must be square
        -there must be an even number of wires (i.e. # no. of columns/rows)
        -all regions have the same number of wires, and the total number of
        wires is divisble by the number of region names passed
        -the list of region names passed reflect the order of regions in the
        coherence matrix; e.g. if ['name1','name2'] is passed for a 16 wire
        dataset, 'name1' one corresponds to wires 1-8 and 'name2' corresponds
        to wires 9-16
        -the argument produces at most 10 Region() objects; currently
        the colors are assigned from a list of 10 colors from
        plt.rcParams['axes.prop_cycle']

    Parameters
    ----------
    df : pandas DataFrame
        a coherence matrix (stored in Coherence_Matrix or
        Coherence_Matrix_Overtime)
    region_names : list
        list of string names to used for constructing Regions.  See
        start of the docstring for assumptions of this argument
    between_regions : bool, optional
        Return Region() objects corresponding to inter-region coherences.
        The default is True.
    within_regions : bool, optional
        Return Region() objects corresponding to intra-region coherences.
        The default is False.
    printout : bool, optional
        Print out the Region() objects made for verification.
        The default is False.

    Returns
    -------
    result : list
        List of Region() objects.

    """
    result = []
    df_cols = len(df.columns)
    df_rows = len(df.index)
    if df_cols != df_rows:
        return result
    num_regions = len(region_names)
    if (df_cols%num_regions) != 0:
        return result
    if df_cols%2 != 0:
        return result
    region_size = int(df_cols/num_regions)

    wirenumbers = range(1, df_cols+1)
    region_to_wirenumbers = []
    for i in range(0, len(wirenumbers), num_regions):
        region_to_wirenumbers.append(list(wirenumbers[i:i+num_regions]))

    interregion_names_clean = []
    intraregion_names = []
    interregion_wires = []
    intraregion_wires = []

    if between_regions:
        #https://stackoverflow.com/questions/8371887/making-all-possible-combinations-of-a-list
        interregion_identities = list(itertools.combinations(range(region_size), 2))
        interregion_names_raw = list(itertools.combinations(region_names, 2))
        interregion_names_clean = []
        for a, b in interregion_names_raw:
            interregion_names_clean.append(str(a) + "-" + str(b))

        interregion_wires = []
        for x,y in interregion_identities:
            interregion_wires.append((region_to_wirenumbers[x],
                                      region_to_wirenumbers[y]))

    if within_regions:
        intraregion_identities = [(i,i) for i in range(num_regions)]
        intraregion_names = list(region_names)
        intraregion_wires = []
        for x,y in intraregion_identities:
            intraregion_wires.append((region_to_wirenumbers[x],
                                      region_to_wirenumbers[y]))

    names_to_use = interregion_names_clean + intraregion_names
    wires_to_use = interregion_wires + intraregion_wires

    #https://stackoverflow.com/questions/42086276/get-default-line-colour-cycle
    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']
    for i, name in enumerate(names_to_use):
        result.append(Region(name,
                             axis1=wires_to_use[i][0],
                             axis2=wires_to_use[i][1],
                             color=colors[i]))
    if printout:
        for reg in result:
            print(reg)
    return result
